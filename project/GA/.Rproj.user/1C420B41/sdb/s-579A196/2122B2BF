{
    "collab_server" : "",
    "contents" : "################################################################\n#\n# Main GA function\n# Xu, Weijie; Chen, Yuwen; Adams, Cameron; Zhou, Yilin\n#\n# Final Projct\n# STAT 243\n# Fall 2017\n#\n################################################################\n\n#' Variable selection using genetic algorithms\n#'\n#' select implements genetic algorithms for variable selection for GLMs by optimizing package or user specified objective functions such as AIC, BIC, and logloglikelihood.\n#' Uses functions: \\code{\\link{generate_founders}}, \\code{\\link{evaluate_fitness}}, and \\code{\\link{create_next_generation}}.\n#' Functions find optimal variables by using evolutationry biology concepts of natural selection, fitness, genetic crossover, and mutation. Founding generation of chromosomes is randomly generated and evaluated using an critieria such as AIC, BIC, or loglihood. Parents are selected by their fitness, and generate children chromosomes. As each generation breeds and produces new genreations, the algorithm moves towards the optimum.\n#'\n#' 1. Geof H. Givens, Jennifer A. Hoeting (2013) Combinatorial Optimization (italicize). Chapter 3 of Computational Statistics (italicize).\n#'\n#' @param Y vector of response variable\n#' @param X a matrix or dataframe of predictor variables\n#' @param family a character string describing the error distribution and link function to be used in the model. Default is gaussian.\n#' @param objective_function function for computing objective. Default is \\code{\\link{stats::AIC}}. User can specify custom function.\n#' @param crossover_parents a function for crossover between mate pairs. User can specify custom function.\n#' @param crossover_method a character string describing crossover method. Default is multi-point crossover.\n#' @param pCrossover a numeric value for he probability of crossover for each mate pair.\n#' @param start_chrom a numeric value for the  size of the popuation of chromosomes. Default is \\code{choose(C, 2)} \\eqn{\\le 200}, where C is number of predictors.\n#' @param mutation_rate a numeric value for rate of mutation. Default is \\eqn{1 / (P \\sqrt C)}, where P is number of chromosomes, and C is number of predictors.\n#' @param converge a logical value indicating whether algorithm should attempt to converge or run for specified number of iterations. If \\code{TRUE}, convergence will occur when highest ranked chromosomes is equal to mean of top 50\\% in current and previous generation.\n#' @param tol a numeric value indicating convergence tolerance. Default is 1e-4.\n#' @param iter an integer specifying maximum number of generations algorithm will produce. Default is 100\n#' @param minimize a logical value indicating whether optimize should be minimized (TRUE) or maximized (FALSE).\n#' @param parallel a logical value indicating whether chromosmes should be evaluated using parallel processes. See \\code{\\link{evaluate_fitness}}.\n#'\n#'If user wants to use custom objective_function, they must use a function that is compatible with \\code{\\link{lm}} or \\code{\\link{glm}} fitted objects which output a numberic value of length 1.\n#'\n#' @examples\n#' # test\n#' rm(list = ls())\n#'\n#' set.seed(1111)\n#'\n#' # simulate data for gaussian GLM\n#' library(simrel)\n#' library(GA)\n#'\n#' n <- 100 # number obs\n#' p <- 10 # number predictors\n#' m <- 2 # number relevant latent components\n#' q <- 5 # number relevant predictors\n#' gamma <- 0.2 # speed of decline in eigenvalues\n#' R2 <- 0.5 # theoretical R-squared according to the true linear model\n#' relpos <- sample(1:p, m, replace = F) # positions of m\n#' dat <- simrel(n, p, m, q, relpos, gamma, R2) # generate data\n#' x <- dat$X\n#' y <- dat$Y\n#'\n#' \\dontrun{test_GA <- GA::select(y, x)}\n#'\n#' # 1. Generate founders:  200 chromosomes\n#' # 2. Evaluate founders\n#' # 3. Begin breeding\n#' # Generations: 1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19-20-21-22-23-24-25-26- #### Converged! ####\n#'\n#' # True data\n#' # dat$relpred\n#' [1]  1  4  5  7 10\n#'\n#' # true beta coefficients\n#' dat$beta\n#'         [,1]\n#' # [1,] -0.21787024\n#' # [2,]  0.00000000\n#' # [3,]  0.00000000\n#' # [4,] -0.68961539\n#' # [5,]  0.67167213\n#' # [6,]  0.00000000\n#' # [7,]  0.03082501\n#' # [8,]  0.00000000\n#' # [9,]  0.00000000\n#' # [10,]  0.20498849\n#'\n#' # GA output\n#' test_GA$BestModel\n#' # [1] \"6\"  \"10\" \"11\" \"12\" \"19\" \"21\" \"25\"\n#'\n#' test_GA$optimize\n#' #$optimize$obj_func\n#' # [1] \"AIC\"\n#' # $optimize$value\n#' # [1] 231.2034\n#' # $optimize$minimize\n#' # [1] TRUE\n#' # $optimize$method\n#' # [1] \"method1\"\n#'\n#' @export\n\nselect <- function(Y, X, family = \"gaussian\",\n                  objective_function = stats::AIC,\n                  crossover_parents_function = crossover_parents,\n                  crossover_method = c(\"method1\", \"method2\", \"method3\"),\n                  pCrossover = 0.8,\n                  start_chrom = NULL,\n                  mutation_rate = NULL,\n                  converge = TRUE,\n                  tol = 1e-4,\n                  iter = 100,\n                  minimize = TRUE,\n                  parallel = FALSE) {\n\n\n    require(parallel)\n\n    ########\n    #error checking\n    ########\n\n    # X\n    if (!is.matrix(X) & !is.data.frame(X)) stop(\"X must be matrix or dataframe\")\n\n    # Y\n    if (!is.vector(Y) & !is.matrix(Y) & ncol(Y) > 1) stop(\"Y must be vector or 1 dimensional matrix\")\n\n    # family\n    if (family == \"gaussian\" & all(Y %% 1 == 0)) {cat(\"Warning: outcome distribution is are 1, 0 integer, family == 'gaussian' may not be suitable\")}\n    if (family == \"gamma\" & sum(Y > 0) > 0) {cat(\"Warning: outcome values < 0, family == 'gamma' may produce errors\")}\n\n    # objective_function\n    if (!is.function(objective_function)) stop(\"Error: objective_function must be a function\")\n\n    # crossover_parents\n    if (!is.function(crossover_parents_function)) stop(\"Error: crossover_parents must be a function\")\n\n    # crossover_method\n    if (!is.character(crossover_method)) stop(\"Error: crossover_method should be a character string\")\n    if (length(crossover_method) > 1) crossover_method <- crossover_method[1]\n\n    # pCrossover\n    if (!is.numeric(pCrossover) | pCrossover < .Machine$double.eps | pCrossover > 1) stop(\"Error: pCrossover must be number between 0 and 1\")\n    if (pCrossover < 0.5) cat(\"Warning: pCrossover < 0.5 may not reach optimum\")\n\n    # mutation_rate\n    if (!is.null(mutation_rate)) {\n        if(!is.numeric(mutation_rate)) stop(\"Error: mutation rate must be numeric\")\n        if(mutation_rate < 0 | mutation_rate > 1) stop(\"Error: mutation rate must be bewteen 0 and 1\")\n    }\n\n    # converge\n    if (!is.logical(converge)) stop(\"Error: converge must be logical (TRUE/FALSE). Default is TRUE\")\n\n    # tol\n    if (!is.numeric(tol)) stop(\"Error: tol must be numeric. Default is 1e-4\")\n\n    # iter\n    if (!is.numeric(iter)) stop(\"Error: iter must be numeric\")\n    if (length(iter) > 1) stop(\"Error: iter be of length one\")\n\n    # minimize\n    if (!is.logical(minimize)) stop(\"Error: minimize must be logical (TRUE/FALSE). Default is TRUE\")\n\n    # parallel\n    if (!is.logical(parallel)) stop(\"Error: parallel must be logical (TRUE/FALSE). Default is TRUE\")\n\n\n    ##########\n    # Perform genetic algorithm\n    #########\n    t1 <- Sys.time() # timing\n\n    # Step 1: Generate founders ----------------\n    generation_t0 <- generate_founders(X, start_chrom)\n    P <- nrow(generation_t0) #num chromosomes\n    cat(\"1. Generate founders: \", P, \"chromosomes\")\n\n\n    # Step 2. Evaluate founder fitness Fitness of inital pop ----------------\n    cat(\"\\n2. Evaluate founders\")\n    obj_fun_output_t0 <- evaluate_fitness(generation_t0, Y, X,\n                                        family,\n                                        parallel, minimize,\n                                        objective_function,\n                                        rank_objective_function)\n\n    #create array to store fitness data for each iteration\n    convergeData <- array(dim = c(P, 2, 1)) #P x 2 x iter\n\n    #save founder fitness evaluation data\n    convergeData[, , 1] <- obj_fun_output_t0[\n                            order(obj_fun_output_t0[, 2], decreasing = T),\n                            c(1, 3)]\n\n    # Step 3. loop through successive generations  ----------------\n    cat(\"\\n3. Begin breeding \\n Generations: \")\n    t1 <- c(t1, Sys.time())\n    for (i in 1:iter) {\n\n        # 1. create next generation ----------------\n        if (i == 1) {\n            generation_t1 <- generation_t0\n            obj_fun_output_t1 <- obj_fun_output_t0\n        }\n\n        generation_t1 <- create_next_generation(generation_t1,\n                                            obj_fun_output_t1,\n                                            select_parents,\n                                            crossover_method,\n                                            crossover_parents_function,\n                                            pCrossover,\n                                            mutate_child,\n                                            mutation_rate)\n\n        # 2. evaluate children fitness ----------------\n        obj_fun_output_t1 <- evaluate_fitness(generation_t1, Y, X,\n                                            family,\n                                            parallel, minimize,\n                                            objective_function,\n                                            rank_objective_function)\n\n        # store fitness data\n        convergeData <- abind::abind(convergeData,\n                                obj_fun_output_t1[order(obj_fun_output_t1[, 2],\n                                decreasing = T), c(1, 3)])\n\n        # cat generation and save timing\n        cat(i, \"-\", sep = \"\")\n\n        # 3. check convergence ----------------\n        if (i > 10 & isTRUE(converge)) {\n            if(isTRUE(all.equal(mean(convergeData[1:(P * 0.25), 2, i]),\n                                convergeData[1, 2, i],\n                                check.names = F,\n                                tolerance = tol)) &\n               isTRUE(all.equal(mean(convergeData[1:(P * 0.25), 2, (i - 1)]),\n                                convergeData[1, 2, i],\n                                check.names = F,\n                                tolerance = tol))) {\n                cat(\"\\n#### Converged! ####\")\n                break\n            }\n        }\n    }\n\n    # Step 4. process output ----------------\n    t1 <- c(t1, Sys.time())\n    best_scores <- convergeData[, , i]\n    best_scores <- best_scores[best_scores[, 2] == best_scores[1, 2], ]\n    bestModel <- generation_t1[convergeData[, 1, i], ]\n    value <- convergeData[1, 2, dim(convergeData)[3]]\n    if(dim(convergeData)[3] < iter) {converged <- \"Yes\"\n    } else {converged <- \"No\"}\n\n    output <- list(\"Best_model\" =\n                       colnames(x)[round(colMeans(bestModel[1:dim(best_scores)[1], ]), 0) == 1],\n                   optimize = list(\"obj_func\" = paste(substitute(objective_function))[3],\n                                 value = as.numeric(round(value, 4)),\n                                 minimize = minimize,\n                                 method = crossover_method),\n                   iter = dim(convergeData)[3],\n                   converged = converged,\n                   convergeData = convergeData,\n                   timing = t1)\n    class(output) <- \"GA\"\n    return(output)\n}\n\n\n",
    "created" : 1513167830120.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3046853411",
    "id" : "2122B2BF",
    "lastKnownWriteTime" : 1513188676,
    "last_content_update" : 1513188676701,
    "path" : "~/repos/STAT243/project/GA/R/select.R",
    "project_path" : "R/select.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}