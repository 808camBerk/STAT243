dat <- simrel(n, p, m, q, relpos, gamma, R2) # generate data
x <- dat$X
y <- dat$Y
output.meth1 <- select(y, x, optimize = "AIC", parallel = F,
converge = T, family = "gaussian")
output.meth1 <- select(y, x, optimize = "AIC", parallel = F,
converge = T, family = "gaussian")
output.meth1
################################################################
#
# Main GA function
# Xu, Weijie; Chen, Yuwen; Adams, Cameron; Zhou, Yilin
#
# Final Projct
# STAT 243
# Fall 2017
#
################################################################
#' Variable selection using genetic algorithms
#'
#' select implements genetic algorithms for variable selection for GLMs by optimizing package or user specified objective functions such as AIC, BIC, and logloglikelihood.
#' Uses functions: \code{\link{generate_founders}}, \code{\link{evaluate_fitness}}, and \code{\link{create_next_generation}}.
#' Functions find optimal variables by using evolutationry biology concepts of natural selection, fitness, genetic crossover, and mutation. Founding generation of chromosomes is randomly generated and evaluated using an critieria such as AIC, BIC, or loglihood. Parents are selected by their fitness, and generate children chromosomes. As each generation breeds and produces new genreations, the algorithm moves towards the optimum.
#'
#' 1. Geof H. Givens, Jennifer A. Hoeting (2013) Combinatorial Optimization (italicize). Chapter 3 of Computational Statistics (italicize).
#'
#' @param Y vector of response variable
#' @param X a matrix or dataframe of predictor variables
#' @param family a character string describing the error distribution and link function to be used in the model. Default is gaussian.
#' @param optimize a character string describing the objective function/critiera to be optimized. Default is AIC.
#' @param calc_objective_function function for optimizies \code{optimize}. Default will optimize AIC, BIC, or loglikelihood. User can specify custom function.
#' @param crossover_parents a function for crossover between mate pairs. User can specify custom function.
#' @param crossover_method a character string describing crossover method. Default is multi-point crossover.
#' @param pCrossover a numeric value for he probability of crossover for each mate pair.
#' @param start_chrom a numeric value for the  size of the popuation of chromosomes. Default is \code{choose(C, 2)} $le$ 200, where C is number of predictors.
#' @param mutation_rate a numeric value for rate of mutation. Default is $1 / (P \sqrt{C})$, where P is number of chromosomes, and C is number of predictors.
#' @param converge a logical value indicating whether algorithm should attempt to converge or run for specified number of iterations. If \code{TRUE}, convergence will occur when highest ranked chromosomes is equal to mean of top 50\% in current and previous generation, with a tolerance of \code{1e4 * sqrt(.Machine$double.eps)}.
#' @param tol a numeric value indicating convergence tolerance. Default is 1e-4.
#' @param iter an integer specifying maximum number of generations algorithm will produce. Default is 100
#' @param minimize a logical value indicating whether optimize should be minimized (TRUE) or maximized (FALSE).
#' @param parallel a logical value indicating whether chromosmes should be evaluated using parallel processes. See \code{\link{evaluate_fitness}}.
#'
#' @examples
#' # select Test
#' rm(list = ls())
#'
#' set.seed(243)
#'
#' # simulate data for gaussian GLM
#' library(simrel)
#' library(GA)
#'
#' n <- 100 # number obs
#' p <-  # number predictors
#' m <- 5 # number relevant latent components
#' q <- 5 # number relevant predictors
#' gamma <- 0.2 # speed of decline in eigenvalues
#' R2 <- 0.5 # theoretical R-squared according to the true linear model
#' relpos <- sample(1:p, m, replace = F) # positions of m
#' dat <- simrel(n, p, m, q, relpos, gamma, R2) # generate data
#' x <- dat$X
#' y <- dat$Y
#'
#' \dontrun{test_GA <- GA::select(Y, X, iter, family = "gaussian", optimize = "AIC", crossover_method = "method1", pCrossover = 0.8, converge = TRUE, minimize = TRUE, parallel = FALSE)}
#'
#' @export
select <- function(Y, X, family = "gaussian",
optimize = c("AIC", "BIC", "logLik"),
objective_function = NULL,
crossover_parents_function = NULL,
crossover_method = c("method1", "method2", "method3"),
pCrossover = 0.8,
start_chrom = NULL,
mutation_rate = NULL,
converge = TRUE,
tol = 1e-4,
iter = 100,
minimize = TRUE,
parallel = FALSE) {
require(abind)
require(parallel)
########
#error checking
########
# X
if (!is.matrix(X) & !is.data.frame(X)) stop("X must be matrix or dataframe")
# Y
if (!is.vector(Y) & !is.matrix(Y) & ncol(Y) > 1) stop("Y must be vector or 1 dimensional matrix")
# family
if (family == "gaussian" & all(Y %% 1 == 0)) {cat("Warning: outcome distribution is are 1, 0 integer, family == 'gaussian' may not be suitable")}
if (family == "gamma" & sum(Y > 0) > 0) {cat("Warning: outcome values < 0, family == 'gamma' may produce errors")}
# optimize
if (length(optimize) != 1 | !is.character(optimize)) stop("Error: optimize should be one character string")
# objective_function
if(missing(objective_function)) {objective_function <- default_objective_function}
if (!is.function(objective_function)) stop("Error: objective_function must be a function")
# crossover_parents
if(missing(crossover_parents_function)) {crossover_parents_function <- crossover_parents}
if (!is.function(crossover_parents_function)) stop("Error: crossover_parents must be a function")
# crossover_method
if (!is.character(crossover_method)) stop("Error: crossover_method should be a character string")
if (length(crossover_method) > 1) crossover_method <- crossover_method[1]
# pCrossover
if (!is.numeric(pCrossover) | pCrossover < .Machine$double.eps | pCrossover > 1) stop("Error: pCrossover must be number between 0 and 1")
if (pCrossover < 0.5) cat("Warning: pCrossover < 0.5 may not reach optimum")
# mutation_rate
if (!is.null(mutation_rate)) {
if(!is.numeric(mutation_rate)) stop("Error: mutation rate must be numeric")
if(mutation_rate < 0 | mutation_rate > 1) stop("Error: mutation rate must be bewteen 0 and 1")
}
# converge
if (!is.logical(converge)) stop("Error: converge must be logical (TRUE/FALSE). Default is TRUE")
# tol
if (!is.numeric(tol)) stop("Error: tol must be numeric. Default is 1e-4")
# iter
if (!is.numeric(iter)) stop("Error: iter must be numeric")
if (length(iter) > 1) stop("Error: iter be of length one")
# minimize
if (!is.logical(minimize)) stop("Error: minimize must be logical (TRUE/FALSE). Default is TRUE")
# parallel
if (!is.logical(parallel)) stop("Error: parallel must be logical (TRUE/FALSE). Default is TRUE")
################
# functions
################
# Select parents function ----------------
select_parents <- function(generation_t0, parent_rank, P) {
# probability of selection ----------------
phi <- (2 * parent_rank) / (P * (P + 1))
#method 1: both parents selected by parent_rank
#parentInd <- sample(1:P, 2, prob=phi, replace = F) #this is better than method 2
#method 2: first parent by parent_rank, second random
parentInd <- c(sample(1:P, 1, prob=phi, replace = F),
sample(1:P, 1, replace = F))
return(parentInd)
}
# crossover function ----------------
crossover_parents <- function(generation_t0, parentInd,
crossover_method, pCrossover, parent_rank)  {
# get parent info
parent1 <- generation_t0[parentInd[1], ]
parent2 <- generation_t0[parentInd[2], ]
C <- length(parent1)
parent1r <- parent_rank[parentInd[1]]
parent2r <- parent_rank[parentInd[2]]
if (rbinom(1, 1, pCrossover) == 1 ) {
if (crossover_method == "method1") {
#METHOD 1 ----------------
#multipoint crossover: three crossover points
cross <- sort(sample(seq(2,(C - 2), 2), 3, replace = F))
child1 <- c(parent1[1:cross[1]],
parent2[(cross[1] + 1):cross[2]],
parent1[(cross[2] + 1):cross[3]],
parent2[(cross[3] + 1):C])
child2 <- c(parent2[1:cross[1]],
parent1[(cross[1] + 1):cross[2]],
parent2[(cross[2] + 1):cross[3]],
parent2[(cross[3] + 1):C])
} else if (crossover_method == "method2") {
#METHOD 2 ----------------
#method upweights parent with higher parent_rank high
childProb <- parent1 * parent1r[1] /
(parent1r + parent2r) +
parent2 * parent2r /
(parent1r + parent2r)
child1 <- rbinom(C, 1, prob = childProb)
child2 <- rbinom(C, 1, prob = childProb)
} else if (crossover_method == "method3") {
#METHOD 3 ----------------
#randomly samples non-concordant variables between parents
# slightly upweights parent selected by prob. proportional to parent_rank
child1 <- parent1
child2 <- parent2
child1[parent1 != parent2] <-
rbinom(sum(parent1 - parent2 != 0), 1,
prob = parent1r / (parent1r + parent2r))
child2[parent1 != parent2] <-
rbinom(sum(parent1 - parent2 != 0), 1,
prob = parent2r / (parent1r + parent2r))
}
return(rbind(child1, child2))
} else {
child1 <- parent1
child2 <- parent2
return(rbind(child1, child2))
}
}
# mutation function ----------------
mutate_child <- function(mutation_rate, child, P, C) {
if (is.null(mutation_rate)) {
return(abs(round(child, 0) -
rbinom(C, 1,
prob = 1 / (P * sqrt(C)))))
} else {
return(abs(round(child, 0) -
rbinom(C, 1,
prob = mutation_rate)))
}
}
# calculate obj function ----------------
default_objective_function <- function(mod, optimize) {
if (optimize == "AIC") {
extractAIC(mod)[2]
} else if (optimize == "BIC") {
BIC(mod)
} else if (optimize == "logLik") {
logLik(mod)
}
}
# parent_rank obj function output ----------------
rank_objective_function <- function(objFunOutput, optimize, minimize) {
if (optimize %in% c("AIC", "BIC") | minimize == TRUE) {
r <- base::rank(-objFunOutput, na.last = TRUE, ties.method = "first")
} else if (optimize == "logLike" | minimize == FALSE) {
r <- base::rank(objFunOutput, na.last = TRUE, ties.method = "first")
}
return(cbind(chr = 1:P, parent_rank = r, objFunOutput))
}
##########
# Perform genetic algorithm
#########
t1 <- Sys.time() # timing
# Step 1: Generate founders ----------------
generation_t0 <- generate_founders(X, start_chrom)
P <- nrow(generation_t0) #num chromosomes
cat("1. Generate founders: ", P, "chromosomes")
# Step 2. Evaluate founder fitness Fitness of inital pop ----------------
cat("\n2. Evaluate founders: ")
objFunOutput_t0 <- evaluate_fitness(generation_t0, Y, X,
family, optimize,
parallel, minimize,
objective_function,
rank_objective_function)
#create array to store fitness data for each iteration
convergeData <- array(dim = c(P, 2, 1)) #P x 2 x iter
#save founder fitness evaluation data
convergeData[, , 1] <- objFunOutput_t0[
order(objFunOutput_t0[, 2], decreasing = T),
c(1, 3)]
# Step 3. loop through successive generations  ----------------
cat("\n3. Begin breeding \n Generations: ")
t1 <- c(t1, Sys.time())
for (i in 1:iter) {
# 1. create next generation ----------------
if (i == 1) {
generation_t1 <- generation_t0
objFunOutput_t1 <- objFunOutput_t0
}
generation_t1 <- create_next_generation(generation_t1,
objFunOutput_t1,
select_parents,
crossover_method,
crossover_parents_function,
pCrossover,
mutate_child,
mutation_rate)
# 2. evaluate children fitness ----------------
objFunOutput_t1 <- evaluate_fitness(generation_t1, Y, X,
family, optimize,
parallel, minimize,
objective_function,
rank_objective_function)
# store fitness data
convergeData <- abind(convergeData,
objFunOutput_t1[order(objFunOutput_t1[, 2],
decreasing = T), c(1, 3)])
# cat generation and save timing
cat(i, "-", sep = "")
# 3. check convergence ----------------
if (i > 10 & isTRUE(converge)) {
if(isTRUE(all.equal(mean(convergeData[1:(P * 0.5), 2, i]),
convergeData[1, 2, i],
check.names = F,
tolerance = tol)) &
isTRUE(all.equal(mean(convergeData[1:(P * 0.5), 2, (i - 1)]),
convergeData[1, 2, i],
check.names = F,
tolerance = tol))) {
cat("\n#### Converged! ####")
break
}
}
}
# Step 4. process output ----------------
t1 <- c(t1, Sys.time())
bestModel <- generation_t1[convergeData[1, 1, i], ]
value <- convergeData[1, 2, dim(convergeData)[3]]
if(dim(convergeData)[3] < iter) {converged <- "Yes"
} else {converged <- "No"}
output <- list("BestModel" = colnames(X)[bestModel == 1],
optimize = list("optimize" = optimize,
value = as.numeric(round(value, 4))),
iter = dim(convergeData)[3],
converged = converged,
convergeData = convergeData,
timing = t1)
return(output)
}
##############
# subfunctions
##############
#initiative founding chromosomes
generate_founders <- function(X, start_chrom) {
# C: number of genes/variables in design matrix
# P: #number of parent chromosomes
# geneSample: Random sample of genes/vars for initial parent dataet
# firstgeneration:
# generation_t:
# number of predictors ---------------
C <- dim(X)[2]
# number of founders ----------------
if (is.null(start_chrom)) {
P <- choose(C, 2)
if (P > 200) {         #check for max chrom
P <- 200 }
if (P %% 2 != 0) {     #check for even number of parents
P <- P - 1
}
} else {
if (start_chrom > 200) cat("Warning: P > 200, algorithm may require lots of running time")
P <- start_chrom #user number of chroms
}
#randomly generate founders ----------------
geneSample <- sample(c(0, 1),
replace = TRUE,
size = ceiling(1.2 * C * P))
#update geneSample to make sure that each gene/variable
#will exist in at least one chrome, but not all.
#geneSample <- c(rep(0, C - 1), rep(1, C), 0, geneSample)
#create a first generation
x <- seq_along(geneSample)
firstGen <- split(geneSample, ceiling(x / C))
generation_t0 <- matrix(unlist(unique(firstGen)[1:P]),
ncol = C, byrow = TRUE)
#generation_t0 <- generation_t0[apply(generation_t0[, -1], 1,
#                                 function(x) !all(x == 0)), ]
generation_t0 <- generation_t0[apply(generation_t0, 1,
function(x) !all(x == 0)), ]
return(generation_t0)
}
evaluate_fitness <- function(generation_t0, Y, X, family, optimize,
parallel, minimize,
calc_objective_function,
rank_objective_function) {
#number parent chromosomes
P <- dim(generation_t0)[1]
######
#evaluate and rank each chromosome with selected objective function
######
# serial ----------------
if (parallel == FALSE) {
# lm ----------------
if (family == "gaussian") {
objFunOutput <- sapply(1:P, function(i) {
mod <- lm(Y ~ X[, generation_t0[i, ] == 1])
calc_objective_function(mod, optimize)
})
# glm ----------------
} else if(family != "gaussian") {
objFunOutput <- sapply(1:P, function(i) {
mod <- glm(Y ~ X[, generation_t0[i, ] == 1], family = family)
calc_objective_function(mod, optimize)
})
}
# parallel ----------------
} else if (parallel == TRUE) {
# mclapply options ----------------
nCores <- detectCores() - 1
if(dim(X)[1] < 1000) {preschedule <- FALSE
} else {preschedule <- TRUE}
# lm ----------------
if (family == "gaussian") {
objFunOutput <- unlist(mclapply(1:P, function(i) {
mod <- lm(Y ~ X[, generation_t0[i, ] == 1])
calc_objective_function(mod, optimize)
}, mc.preschedule = preschedule, mc.cores = nCores))
# glm ----------------
} else if(family != "gaussian") {
objFunOutput <- unlist(mclapply(1:P, function(i) {
mod <- glm(Y ~ X[, generation_t0[i, ] == 1], family = family)
calc_objective_function(mod, optimize)
}, mc.preschedule = preschedule, mc.cores = nCores))
}
}
# rank ----------------
parent_rank <- rank_objective_function(objFunOutput, optimize, minimize)
# return rankings ----------------
return(parent_rank)
}
create_next_generation <- function(generation_t0, objFunOutput_t0,
select_parents,
crossover_method,
crossover_parents,
pCrossover,
mutate_child,
mutation_rate) {
# set variables and
P <- dim(generation_t0)[1]
C <- dim(generation_t0)[2]
parent_rank <- objFunOutput_t0[, 2]
#select_parents <- match.fun(select_parents)
#crossover_parents <- match.fun(crossover_parents)
#mutate_child <- match.fun(mutate_child)
#Create matrix for next generation
generation_t1 <- matrix(NA, dim(generation_t0)[1], dim(generation_t0)[2])
#########
#Selection, Crossover, and Mutation
#########
i <- 1 #initialize while loop
while(i <= dim(generation_t1)[1]) {
# Selection ----------------
parentInd <- select_parents(generation_t0, parent_rank, P)
# Crossover ----------------
children <- crossover_parents(generation_t0, parentInd,
crossover_method, pCrossover, parent_rank)
# Mutation ----------------
child1 <- mutate_child(mutation_rate, children[1, ], P, C)
child2 <- mutate_child(mutation_rate, children[2, ], P, C)
# Check child dups and all zeros -----------------
if (all(!rowSums(generation_t1 == child1, na.rm = T) == C,
!rowSums(generation_t1 == child2, na.rm = T) == C) &
sum(child1) > 0 & sum(child2) > 0) {
generation_t1[c(i, i + 1), ] <- rbind(child1, child2)
# update counter
i <- i + 2
}
}
# return new new generation
return(generation_t1)
}
##############
# simulation
##############
# simulate toy dataset
library(simrel)
n <- 100 # number obs
p <- 10 # number predictors
m <- 5 # number relevant latent components
q <- 5 # number relevant predictors
gamma <- 0.2 # speed of decline in eigenvalues
R2 <- 0.5 # theoretical R-squared according to the true linear model
relpos <- sample(1:p, m, replace = F) # positions of m
dat <- simrel(n, p, m, q, relpos, gamma, R2) # generate data
x <- dat$X
y <- dat$Y
##############
#test function with simulated data
##############
output.meth1 <- select(y, x, optimize = "AIC", parallel = F,
converge = T, family = "gaussian")
output.meth1.all <- select(y, x, iter = 100, optimize = "AIC", parallel = F,
crossover_method = "method1", converge = F, family = "gaussian",
pCrossover = 0.9)
output.meth2 <- select(y, x, iter = 100, optimize = "AIC", parallel = F,
crossover_method = "method2", converge = T, family = "gaussian",
pCrossover = 0.9)
output.meth2.all <- select(y, x, iter = 100, optimize = "AIC", parallel = F,
crossover_method = "method2", converge = F, family = "gaussian",
pCrossover = 0.9)
output.meth3 <- select(y, x, iter = 100, optimize = "AIC", parallel = F,
crossover_method = "method3", converge = T, family = "gaussian",
pCrossover = 0.9)
output.meth3.all <- select(y, x, iter = 100, optimize = "AIC", parallel = F,
crossover_method = "method3", converge = F, family = "gaussian",
pCrossover = 0.9)
test <- rbind(c(output.meth1$optimize, output.meth1$iter),
c(output.meth1.all$optimize, output.meth1.all$iter),
c(output.meth2$optimize,     output.meth2$iter),
c(output.meth2.all$optimize, output.meth2.all$iter),
c(output.meth3$optimize,     output.meth3$iter),
c(output.meth3$optimize,     output.meth3.all$iter))
colnames(test) <- c("optimize", "value", "iterations")
rownames(test) <- grep("output.meth", ls(), value = T)
test
dat$relpred
output.meth1$BestModel
output.meth1.all$BestModel
output.meth2$BestModel
output.meth2.all$BestModel
output.meth3$BestModel
output.meth3.all$BestModel
plots <- grep("output.meth", ls(), value = T)
for (i in 1:length(plots)) {
output <- eval(parse(text = plots[i]))
convergeData <- output$convergeData
require(scales)
#png(paste0("~/repos/STAT243/project/GAplots_method_0", i, ".png"),
#    width = 640, heigh = 480)
par(mfrow = (c(1, 1)))
#all AIC across interations
plot(jitter(rep(1, nrow(convergeData))), convergeData[, 2, 1], type = "p",
pch = 19, col = alpha("blue", 0.1),
ylim = c(min(convergeData[, 2, ], na.rm = T),
max(convergeData[, 2, ], na.rm = T)),
xlim = c(1, output$iter), xlab = "Generations", ylab = "AIC",
main = paste("GA performance using \n optimize = AIC, lm \n, ",
plots[i]))
for (i in 2:output$iter) {
points(jitter(rep(i, nrow(convergeData))), convergeData[, 2, i], type = "p",
pch = 19, col = alpha("blue", 0.25))
}
#best AIC per iteration
lines(1:output$iter, sapply(1:output$iter,
function(x) convergeData[1, 2, x]), type = "l",
xlab = "iterations", ylab = "AIC", col = "red", lwd = 2,
main = paste("Best AIC per iteration \n optimize = AIC, lm \n",
plots[i]))
lines(1:output$iter, sapply(1:output$iter,
function(x) mean(convergeData[, 2, x])),
lty = 2, lwd = 2, col = "red")
#dev.off()
}
?mcmapply
